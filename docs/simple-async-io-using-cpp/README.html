<h1>Simple Async IO Using C++17</h1>
<p><em>2022-11-19</em></p>
<h2>An Example of What We'll Be Building</h2>
<div class="highlight highlight-source-c++"><pre><span class="pl-c"><span class="pl-c">//</span> example.cpp</span>

<span class="pl-c"><span class="pl-c">//</span> An echo server demonstrating the API we'll be building.</span>



#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>context.hpp<span class="pl-pds">"</span></span>

#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>helpers.hpp<span class="pl-pds">"</span></span>

#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>socket.hpp<span class="pl-pds">"</span></span>



<span class="pl-k">struct</span> <span class="pl-en">Server</span>;



<span class="pl-k">struct</span> <span class="pl-en">Client</span> {

    Server* server = <span class="pl-c1">nullptr</span>;



    Socket socket;

    <span class="pl-k">bool</span> closed = <span class="pl-c1">false</span>;



    <span class="pl-k">char</span> buf[<span class="pl-c1">128</span>];



    <span class="pl-en">Client</span>(Server&amp; server, Socket socket) : server{&amp;server}, socket{<span class="pl-c1">std::move</span>(socket)} {

        <span class="pl-c"><span class="pl-c">//</span> Start the receive loop</span>

        server-&gt;<span class="pl-smi">io_context</span>.<span class="pl-c1">async_recv</span>(<span class="pl-c1">this</span>-&gt;<span class="pl-smi">socket</span>, buf, <span class="pl-k">sizeof</span>(buf),

                                      [<span class="pl-c1">this</span>](<span class="pl-k">int</span> len) { <span class="pl-c1">recv_handler</span>(len); });

    }



    <span class="pl-k">void</span> <span class="pl-en">recv_handler</span>(<span class="pl-k">int</span> len) {

        <span class="pl-k">if</span> (len &lt;= <span class="pl-c1">0</span>) {

            closed = <span class="pl-c1">true</span>;

            <span class="pl-k">return</span>;

        }



        <span class="pl-c1">std::printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Received: %.*s.<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, len, buf);



        <span class="pl-c"><span class="pl-c">//</span> Copy the buffer onto the heap and tie its lifetime to</span>

        <span class="pl-c"><span class="pl-c">//</span> that of the lambda</span>

        <span class="pl-k">auto</span> shared_buf = std::make_shared&lt;std::vector&lt;<span class="pl-k">char</span>&gt;&gt;();



        shared_buf.<span class="pl-c1">resize</span>(len);

        <span class="pl-c1">std::memcpy</span>(shared_buf-&gt;<span class="pl-c1">data</span>(), buf, len);



        <span class="pl-k">auto</span> buf_data = shared_buf-&gt;<span class="pl-c1">data</span>();



        <span class="pl-c"><span class="pl-c">//</span> Write everything we received back</span>

        <span class="pl-c1">async_send_all</span>(server-&gt;<span class="pl-smi">io_context</span>, socket, buf_data, len,

                       [shared_buf = <span class="pl-c1">std::move</span>(shared_buf)](<span class="pl-k">int</span>) {});



        <span class="pl-c"><span class="pl-c">//</span> Queue this client to receive more</span>

        server-&gt;<span class="pl-smi">io_context</span>.<span class="pl-c1">async_recv</span>(<span class="pl-c1">this</span>-&gt;<span class="pl-smi">socket</span>, buf, <span class="pl-k">sizeof</span>(buf),

                                      [<span class="pl-c1">this</span>](<span class="pl-k">int</span> len) { <span class="pl-c1">recv_handler</span>(len); });

    }

};



<span class="pl-k">struct</span> <span class="pl-en">Server</span> {

    IOContext io_context;



    Socket socket;



    std::list&lt;Client&gt; clients;



    <span class="pl-en">Server</span>(<span class="pl-k">unsigned</span> <span class="pl-k">short</span> port) : socket{Socket::ListenParams{port}} {}



    <span class="pl-k">void</span> <span class="pl-en">run</span>() {

        io_context.<span class="pl-c1">async_accept</span>(socket,

                                [<span class="pl-c1">this</span>](Socket socket) { <span class="pl-c1">accept_handler</span>(<span class="pl-c1">std::move</span>(socket)); });

        io_context.<span class="pl-c1">run</span>();

    }



    <span class="pl-k">void</span> <span class="pl-en">accept_handler</span>(Socket socket) {

        <span class="pl-c"><span class="pl-c">//</span> Remove disconnected clients</span>

        <span class="pl-k">auto</span> clients_end =

            <span class="pl-c1">std::remove_if</span>(clients.<span class="pl-c1">begin</span>(), clients.<span class="pl-c1">end</span>(), [](<span class="pl-k">auto</span>&amp; c) { <span class="pl-k">return</span> c.<span class="pl-smi">closed</span>; });



        clients.<span class="pl-c1">erase</span>(clients_end, clients.<span class="pl-c1">end</span>());



        <span class="pl-c"><span class="pl-c">//</span> Add the new socket</span>

        clients.<span class="pl-c1">emplace_back</span>(*<span class="pl-c1">this</span>, <span class="pl-c1">std::move</span>(socket));



        <span class="pl-c"><span class="pl-c">//</span> Continue accepting more clients</span>

        io_context.<span class="pl-c1">async_accept</span>(socket,

                                [<span class="pl-c1">this</span>](Socket socket) { <span class="pl-c1">accept_handler</span>(<span class="pl-c1">std::move</span>(socket)); });

    }

};



<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span>** argv) {

#<span class="pl-k">ifdef</span> SERVER

    <span class="pl-c"><span class="pl-c">//</span> Async IO server</span>

    Server server{<span class="pl-c1">42690</span>};



    server.<span class="pl-c1">run</span>();

#<span class="pl-k">else</span>

    <span class="pl-c"><span class="pl-c">//</span> Simple synchronous client</span>

    Socket socket{Socket::ConnectParams{argv[<span class="pl-c1">1</span>], <span class="pl-k">static_cast</span>&lt;<span class="pl-k">unsigned</span> <span class="pl-k">short</span>&gt;(argv[<span class="pl-c1">2</span>])}};



    socket.<span class="pl-c1">set_non_blocking</span>(<span class="pl-c1">false</span>);



    std::string s;



    <span class="pl-k">while</span> (<span class="pl-c1">std::getline</span>(std::cin, s)) {

        <span class="pl-c1">send_all</span>(socket, s.<span class="pl-c1">data</span>(), s.<span class="pl-c1">size</span>());

        <span class="pl-c1">recv_all</span>(socket, s.<span class="pl-c1">data</span>(), s.<span class="pl-c1">size</span>());



        <span class="pl-c1">std::printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Received: %s<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, s.<span class="pl-c1">c_str</span>());

    }

#<span class="pl-k">endif</span>



    <span class="pl-k">return</span> <span class="pl-c1">0</span>;

}
</pre></div>